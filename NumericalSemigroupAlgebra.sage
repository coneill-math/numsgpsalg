'''final copy'''
class NumericalSemigroupAlg():
	def __init__(self,gens,ringsize):
		self.semigroup = NumericalSemigroup(gens)
		self.ring = PolynomialRing(GF(ringsize), x)
		self.dicty={}
	
	def __contains__(self,poly):
		return self.__checkSemiGroup(poly.factor())
	
	def factorization(self,element):
		factorlist=[x[0] for x in element.factor() for i in range(0,x[1])]
		self.__Tree(element.factor(),factorlist,element.factor())
		return self.dicty[element]
	
	def __Tree(self,element,factorlist,master):
		if not factorlist:
			if master.expand() not in self.dicty:
				self.dicty[master.expand()]=[[master.expand()]]
			return
		if element==master:
			pass
		else:
			if not self.__checkSemiGroup(element):
				self.dicty[element.expand()]=[]
			elif self.__checkSemiGroup(master/element):
				if (master/element).expand() not in self.dicty:
					self.__Tree(master/element,[x[0] for x in master/element for i in range(0,x[1])],master/element)
				if element.expand() not in self.dicty:
					self.__Tree(element,factorlist,element)
				if master.expand() not in self.dicty:
					self.dicty[master.expand()]=[]
				for e1 in self.dicty[element.expand()]:
					for e2 in self.dicty[(master/element).expand()]:
						composition=e1+e2
						composition.sort()
						if composition not in self.dicty[master.expand()]:
							self.dicty[master.expand()].append(composition)
		#else:
		#   if element.expand() not in self.dicty:
		#      self.__Tree(element,factorlist,element)
		for i in set(factorlist):
			templist=deepcopy(factorlist)
			del templist[i]
			self.__Tree(element/factorlist[i],templist,master)
	
	def __checkSemiGroup(self,element): #returns True if in semigroup
		coefflist=element.expand().coefficients(sparse=false)
		if [i for i in range(1,len(coefflist)) if i not in self.semigroup and coefflist[i]!=0] or len(coefflist)<=1:
			return False
			return True
	
	def isIrreducible(self,element,recursive=True):
		if not recursive:
			self.__nonIsIrreducible(element)
		factorlist=[x[0] for x in element.factor() for i in range(0,x[1]) if x[1] in self.semigroup]
		self.isRed=True
		self.master=element.factor()
		self.__reducibilityTree(element.factor(),factorlist)
		return self.isRed
	
	def __reducibilityTree(self,element,factorlist):
		if not factorlist or not self.isRed:
			return
		if self.__checkSemiGroup(self.master/element) and self.__checkSemiGroup(element):
			self.isRed=False
			return
		for i in range(0,len(set(factorlist))):
			templist=deepcopy(factorlist)
			del templist[i]
			self.__reducibilityTree(element/factorlist[i],templist)
	
	def __nonIsIrreducible(self,element):
		element=element.factor()
		factorlist=[x[0] for x in element for i in range(0,x[1])]
		for i in range(1,round(len(factorlist)/2)+1):
			for el in set(itertools.combinations(factorlist,i)):
				temp=1
				for pol in el:
					temp*=pol
				temp=temp.factor()
				if self.__checkSemiGroup(temp) and self.__checkSemiGroup(element/temp):
					return False
		return True
	
	def __repr__(self):
		return 'Numerical Semigroup Algebra object generated by the semigroup {} in the ring with {} elements'.format(self.semigroup.gens,self.ring)

